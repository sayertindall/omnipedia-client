================================================================
Repository Structure
================================================================
app/
  api/
    data/
      route.ts
  globals.css
  layout.tsx
  page.tsx
lib/
  eval.ts
  getData.ts
  utils.ts

================================================================
Repository Files
================================================================

================
File: app/api/data/route.ts
================
import { NextResponse } from "next/server";
import { getData } from "@/lib/getData";

export async function GET(request: Request) {
  const data = await getData();

  if (data === null) {
    return NextResponse.json({ error: "File not found" }, { status: 404 });
  }

  return NextResponse.json({
    ...data,
  });
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import localFont from "next/font/local";
import "./globals.css";

const geistSans = localFont({
  src: "./fonts/GeistVF.woff",
  variable: "--font-geist-sans",
  weight: "100 900",
});
const geistMono = localFont({
  src: "./fonts/GeistMonoVF.woff",
  variable: "--font-geist-mono",
  weight: "100 900",
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

================
File: app/page.tsx
================
"use client";

import { useEffect, useState } from "react";
import { ArticleRenderer } from "@/components/ArticleRenderer";
import { SidePanel } from "@/components/SidePanel";
import { HighlightToggle } from "@/components/HighlightToggle";
import useSWR from "swr";

export default function Page() {
  const [selectedText, setSelectedText] = useState<string | null>(null);
  const [selectedType, setSelectedType] = useState<
    "section" | "sentence" | null
  >(null);
  const [isSidePanelOpen, setSidePanelOpen] = useState(false);
  const [highlightEnabled, setHighlightEnabled] = useState(true);

  const fetcher = (url: string) => fetch(url).then((res) => res.json());

  const { data, error } = useSWR("/api/data", fetcher, {
    revalidateOnFocus: false,
    revalidateOnReconnect: false,
  });

  useEffect(() => {
    console.log("DATA: ", data);
  }, [data]);

  const handleElementClick = (
    text: string,
    type: "section" | "sentence",
    sectionIdx: number,
    sentenceIdx?: number
  ) => {
    // if type == section, idx == section idx
    // if type == sentence, idx == section idx + sentence idx
    // setSelectedText(text);
    // setSelectedType(type);
    // setSidePanelOpen(true);
    if (type === "section") {
      console.log("Section clicked:", data.article[sectionIdx].content);
      // Set the evaluation data for the section
      const sectionEvaluation = data.evaluation.sections.find(
        (section) => section.index === sectionIdx + 1
      );
      console.log("Section Evaluation:", sectionEvaluation);
    } else if (type === "sentence" && sentenceIdx !== undefined) {
      console.log(
        "Sentence clicked:",
        data.article[sectionIdx].sentences[sentenceIdx]
      );
      // Set the evaluation data for the sentence
      const sectionEvaluation = data.evaluation.sections.find(
        (section) => section.index === sectionIdx + 1
      );
      const sentenceEvaluation = sectionEvaluation?.sentence_evaluations.find(
        (sentence) => sentence.index === sentenceIdx + 1
      );
      console.log("Sentence Evaluation:", sentenceEvaluation);
    }
  };

  if (error) return <div>Error loading data</div>;
  if (!data) return <div>Loading...</div>;

  return (
    <div className="container mx-auto p-4">
      <div className="mb-4">
        <HighlightToggle
          enabled={highlightEnabled}
          onToggle={() => setHighlightEnabled(!highlightEnabled)}
        />
      </div>

      <ArticleRenderer
        articleData={data.article}
        onElementClick={handleElementClick}
        highlightEnabled={highlightEnabled}
      />

      <SidePanel
        isOpen={isSidePanelOpen}
        onClose={() => setSidePanelOpen(false)}
        selectedText={selectedText}
        selectedType={selectedType}
        evaluationData={data.evaluation}
        requirementsData={data.requirements}
      />
    </div>
  );
}

================
File: lib/eval.ts
================
/* -------------------------------------
 * 1. Data Structure Interfaces
 * ------------------------------------- */

/**
 * Interface representing a single requirement evaluation.
 */
interface RequirementEvaluation {
  requirement_id: string;
  requirement_category: string;
  classification: string;
  applicable: boolean;
  applicability_reasoning: string;
  score: number;
  confidence: number;
  evidence: string;
  reasoning: string;
  overlap_notes?: string;
}

/**
 * Interface representing the evaluation of a single sentence.
 */
interface SentenceEvaluation {
  index: number;
  sentence: string;
  requirement_evaluations: RequirementEvaluation[];
  meta_notes?: string | null;
}

/**
 * Interface representing evaluation details of an entire section, including its sentences.
 */
interface SectionEvaluation {
  index: number;
  title: string;
  sentence_evaluations: SentenceEvaluation[];
  requirement_evaluations: RequirementEvaluation[];
  meta_notes?: string | null;
}

/**
 * Interface representing the overall article evaluation.
 */
interface ArticleEvaluation {
  requirement_evaluations: RequirementEvaluation[];
  meta_notes?: string | null;
}

/**
 * The main interface representing the entire evaluation data structure.
 */
interface EvaluationData {
  sections: SectionEvaluation[];
  article_evaluation: ArticleEvaluation;
}

/* -------------------------------------
 * 2. Data Retrieval Utility Functions
 * ------------------------------------- */

/**
 * Retrieves a section by its index from the evaluation data.
 * @param data - The entire evaluation data structure.
 * @param sectionIndex - The index of the section to retrieve.
 * @returns The `SectionEvaluation` object if found, or `undefined` if not found.
 */
function getSectionByIndex(
  data: EvaluationData,
  sectionIndex: number
): SectionEvaluation | undefined {
  return data.sections.find((section) => section.index === sectionIndex);
}

/**
 * Retrieves a sentence by its index from a specific section in the evaluation data.
 * @param data - The entire evaluation data structure.
 * @param sectionIndex - The index of the section containing the sentence.
 * @param sentenceIndex - The index of the sentence to retrieve.
 * @returns The `SentenceEvaluation` object if found, or `undefined` if not found.
 */
function getSentenceByIndex(
  data: EvaluationData,
  sectionIndex: number,
  sentenceIndex: number
): SentenceEvaluation | undefined {
  const section = getSectionByIndex(data, sectionIndex);
  return section?.sentence_evaluations.find(
    (sentence) => sentence.index === sentenceIndex
  );
}

/**
 * Retrieves the requirement evaluation for a specific requirement from a given sentence.
 * @param data - The entire evaluation data structure.
 * @param sectionIndex - The index of the section containing the sentence.
 * @param sentenceIndex - The index of the sentence containing the requirement.
 * @param requirementId - The ID of the requirement to retrieve.
 * @returns The requirement evaluation if found, or undefined otherwise.
 */
function getRequirementEvaluationForSentence(
  data: EvaluationData,
  sectionIndex: number,
  sentenceIndex: number,
  requirementId: string
): RequirementEvaluation | undefined {
  const sentence = getSentenceByIndex(data, sectionIndex, sentenceIndex);
  return sentence?.requirement_evaluations.find(
    (re) => re.requirement_id === requirementId
  );
}

/**
 * Retrieves all requirement evaluations for a given requirement ID across all sentences in a section.
 * @param data - The entire evaluation data structure.
 * @param sectionIndex - The index of the section to search within.
 * @param requirementId - The ID of the requirement to retrieve evaluations for.
 * @returns An array of requirement evaluations for the specified requirement, which may be empty if none are found.
 */
function getRequirementEvaluationsForSection(
  data: EvaluationData,
  sectionIndex: number,
  requirementId: string
): RequirementEvaluation[] {
  const section = getSectionByIndex(data, sectionIndex);
  if (!section) return [];

  const evaluations: RequirementEvaluation[] = [];

  // Check section-level requirement evaluations
  section.requirement_evaluations.forEach((re) => {
    if (re.requirement_id === requirementId) {
      evaluations.push(re);
    }
  });

  // Check each sentence's requirement evaluations
  section.sentence_evaluations.forEach((sentence) => {
    sentence.requirement_evaluations.forEach((re) => {
      if (re.requirement_id === requirementId) {
        evaluations.push(re);
      }
    });
  });

  return evaluations;
}

/* -------------------------------------
 * 3. Score Calculation Utility Functions
 * ------------------------------------- */

/**
 * Computes the aggregate score of a section by averaging all requirement evaluation scores.
 * @param data - The entire evaluation data structure.
 * @param sectionIndex - The index of the section to compute the score for.
 * @returns The average score for the section, or 0 if there are no scores.
 */
function getSectionAggregateScore(
  data: EvaluationData,
  sectionIndex: number
): number {
  const section = getSectionByIndex(data, sectionIndex);
  if (!section) return 0;

  const allScores: number[] = [];

  // Add section-level requirement evaluation scores
  section.requirement_evaluations.forEach((re) => {
    allScores.push(re.score);
  });

  // Add scores from each sentence's requirement evaluations
  section.sentence_evaluations.forEach((sentence) => {
    sentence.requirement_evaluations.forEach((re) => {
      allScores.push(re.score);
    });
  });

  if (allScores.length === 0) return 0;

  const sum = allScores.reduce((a, b) => a + b, 0);
  return sum / allScores.length;
}

/**
 * Computes the aggregate score of a sentence by averaging all requirement evaluation scores.
 * @param data - The entire evaluation data structure.
 * @param sectionIndex - The index of the section containing the sentence.
 * @param sentenceIndex - The index of the sentence to compute the score for.
 * @returns The average score for the sentence, or 0 if there are no scores.
 */
function getSentenceAggregateScore(
  data: EvaluationData,
  sectionIndex: number,
  sentenceIndex: number
): number {
  const sentence = getSentenceByIndex(data, sectionIndex, sentenceIndex);
  if (!sentence) return 0;

  const scores: number[] = sentence.requirement_evaluations.map(
    (re) => re.score
  );

  if (scores.length === 0) return 0;

  const sum = scores.reduce((a, b) => a + b, 0);
  return sum / scores.length;
}

/**
 * Computes the overall article score by averaging the aggregate scores of all sections.
 * @param data - The entire evaluation data structure.
 * @returns The average score for the entire article, or 0 if there are no sections.
 */
function getOverallArticleScore(data: EvaluationData): number {
  if (data.sections.length === 0) return 0;

  const sectionScores = data.sections.map((section) =>
    getSectionAggregateScore(data, section.index)
  );

  if (sectionScores.length === 0) return 0;

  const sum = sectionScores.reduce((a, b) => a + b, 0);
  return sum / sectionScores.length;
}

/**
 * Computes the average score for a specific requirement across all sentences in a section.
 * @param data - The entire evaluation data structure.
 * @param sectionIndex - The index of the section to evaluate.
 * @param requirementId - The ID of the requirement to calculate the average score for.
 * @returns The average score for the specified requirement in the given section, or 0 if not applicable.
 */
function getAverageScoreForRequirementInSection(
  data: EvaluationData,
  sectionIndex: number,
  requirementId: string
): number {
  const evaluations = getRequirementEvaluationsForSection(
    data,
    sectionIndex,
    requirementId
  );

  if (evaluations.length === 0) return 0;

  const sum = evaluations.reduce((a, b) => a + b.score, 0);
  return sum / evaluations.length;
}

/**
 * Computes the average score for a specific requirement across the entire article.
 * @param data - The entire evaluation data structure.
 * @param requirementId - The ID of the requirement to calculate the average score for.
 * @returns The average score for the specified requirement across the article, or 0 if not applicable.
 */
function getAverageScoreForRequirementInArticle(
  data: EvaluationData,
  requirementId: string
): number {
  const allEvaluations: RequirementEvaluation[] = [];

  data.sections.forEach((section) => {
    section.requirement_evaluations.forEach((re) => {
      if (re.requirement_id === requirementId) {
        allEvaluations.push(re);
      }
    });
    section.sentence_evaluations.forEach((sentence) => {
      sentence.requirement_evaluations.forEach((re) => {
        if (re.requirement_id === requirementId) {
          allEvaluations.push(re);
        }
      });
    });
  });

  if (allEvaluations.length === 0) return 0;

  const sum = allEvaluations.reduce((a, b) => a + b.score, 0);
  return sum / allEvaluations.length;
}

/* -------------------------------------
 * 4. Additional Utility Functions
 * ------------------------------------- */

/**
 * Retrieves all requirements evaluated for a specific sentence.
 * @param data - The entire evaluation data structure.
 * @param sectionIndex - The index of the section containing the sentence.
 * @param sentenceIndex - The index of the sentence to retrieve requirements from.
 * @returns An array of `RequirementEvaluation` objects for the specified sentence.
 */
function getAllRequirementsForSentence(
  data: EvaluationData,
  sectionIndex: number,
  sentenceIndex: number
): RequirementEvaluation[] {
  const sentence = getSentenceByIndex(data, sectionIndex, sentenceIndex);
  return sentence ? sentence.requirement_evaluations : [];
}

/**
 * Retrieves all requirements evaluated for a specific section, including sentence-level requirements.
 * @param data - The entire evaluation data structure.
 * @param sectionIndex - The index of the section to retrieve requirements from.
 * @returns An array of `RequirementEvaluation` objects for the specified section and its sentences.
 */
function getAllRequirementsForSection(
  data: EvaluationData,
  sectionIndex: number
): RequirementEvaluation[] {
  const section = getSectionByIndex(data, sectionIndex);
  if (!section) return [];

  const evaluations: RequirementEvaluation[] = [
    ...section.requirement_evaluations,
  ];

  section.sentence_evaluations.forEach((sentence) => {
    evaluations.push(...sentence.requirement_evaluations);
  });

  return evaluations;
}

/**
 * Retrieves all requirements evaluated for the entire article.
 * @param data - The entire evaluation data structure.
 * @returns An array of `RequirementEvaluation` objects for the entire article.
 */
function getAllRequirementsForArticle(
  data: EvaluationData
): RequirementEvaluation[] {
  const evaluations: RequirementEvaluation[] = [
    ...data.article_evaluation.requirement_evaluations,
  ];

  data.sections.forEach((section) => {
    evaluations.push(...section.requirement_evaluations);
    section.sentence_evaluations.forEach((sentence) => {
      evaluations.push(...sentence.requirement_evaluations);
    });
  });

  return evaluations;
}

/* -------------------------------------
 * 5. Example Usage of the Utility Functions
 * ------------------------------------- */

// Assume `evaluationData` is your JSON data parsed into the `EvaluationData` interface
// For demonstration, let's create a minimal example (replace with your actual data):

const evaluationData: EvaluationData = {
  sections: [
    {
      index: 1,
      title: "Overview",
      sentence_evaluations: [
        {
          index: 1,
          sentence: "Sentence 1.",
          requirement_evaluations: [
            {
              requirement_id: "R1",
              requirement_category: "Content",
              classification: "Imperative Standards",
              applicable: true,
              applicability_reasoning:
                "Applicable because this is just a demo requirement evaluation.",
              score: 0.5,
              confidence: 0.8,
              evidence: "Sample evidence.",
              reasoning: "Sample reasoning.",
            },
          ],
        },
      ],
      requirement_evaluations: [
        {
          requirement_id: "R25",
          requirement_category: "Structure",
          classification: "Imperative Standards",
          applicable: true,
          applicability_reasoning: "Sample applicability reasoning.",
          score: 1.0,
          confidence: 0.95,
          evidence: "Section-level evidence.",
          reasoning: "Section-level reasoning.",
        },
      ],
    },
  ],
  article_evaluation: {
    requirement_evaluations: [
      {
        requirement_id: "R35",
        requirement_category: "Citations",
        classification: "Best Practices",
        applicable: true,
        applicability_reasoning:
          "Sample applicability reasoning for the article.",
        score: 0,
        confidence: 0.95,
        evidence: "No inline citations found.",
        reasoning: "Article-level reasoning.",
      },
    ],
  },
};

// Usage Examples:

// 1. Get the aggregate score for a specific section by index
const sectionIndex = 1;
const sectionScore = getSectionAggregateScore(evaluationData, sectionIndex);
console.log(`Section ${sectionIndex} aggregate score: ${sectionScore}`);

// 2. Get the aggregate score for a specific sentence by section and sentence indexes
const sentenceIndex = 1;
const sentenceScore = getSentenceAggregateScore(
  evaluationData,
  sectionIndex,
  sentenceIndex
);
console.log(
  `Sentence ${sentenceIndex} in Section ${sectionIndex} aggregate score: ${sentenceScore}`
);

// 3. Retrieve a specific requirement evaluation from a sentence
const requirementId = "R1";
const specificRequirementEvaluation = getRequirementEvaluationForSentence(
  evaluationData,
  sectionIndex,
  sentenceIndex,
  requirementId
);
console.log(
  `Specific requirement evaluation for requirement ${requirementId}:`,
  specificRequirementEvaluation
);

// 4. Get overall article score
const overallScore = getOverallArticleScore(evaluationData);
console.log(`Overall article score: ${overallScore}`);

// 5. Retrieve all evaluations of a specific requirement across a section
const sectionRequirementEvaluations = getRequirementEvaluationsForSection(
  evaluationData,
  sectionIndex,
  requirementId
);
console.log(
  `All ${requirementId} requirement evaluations in Section ${sectionIndex}:`,
  sectionRequirementEvaluations
);

// 6. Compute the average score for a specific requirement across all sentences in a section
const averageScoreForRequirementInSection =
  getAverageScoreForRequirementInSection(
    evaluationData,
    sectionIndex,
    requirementId
  );
console.log(
  `Average score for requirement ${requirementId} in Section ${sectionIndex}: ${averageScoreForRequirementInSection}`
);

// 7. Compute the average score for a specific requirement across the entire article
const averageScoreForRequirementInArticle =
  getAverageScoreForRequirementInArticle(evaluationData, requirementId);
console.log(
  `Average score for requirement ${requirementId} across the article: ${averageScoreForRequirementInArticle}`
);

// 8. Retrieve all requirements evaluated for a specific sentence
const allRequirementsForSentence = getAllRequirementsForSentence(
  evaluationData,
  sectionIndex,
  sentenceIndex
);
console.log(
  `All requirements evaluated for Sentence ${sentenceIndex} in Section ${sectionIndex}:`,
  allRequirementsForSentence
);

// 9. Retrieve all requirements evaluated for a specific section
const allRequirementsForSectionData = getAllRequirementsForSection(
  evaluationData,
  sectionIndex
);
console.log(
  `All requirements evaluated for Section ${sectionIndex}:`,
  allRequirementsForSectionData
);

// 10. Retrieve all requirements evaluated for the entire article
const allRequirementsForArticleData =
  getAllRequirementsForArticle(evaluationData);
console.log(
  `All requirements evaluated for the entire article:`,
  allRequirementsForArticleData
);

================
File: lib/getData.ts
================
import { join } from "path";
import { readFile } from "fs/promises";

export const getData = async () => {
  const article_path = join(process.cwd(), "public", "article.json");
  const eval_path = join(process.cwd(), "public", "evaluation.json");
  const req_path = join(process.cwd(), "public", "requirements.json");

  const article = JSON.parse(await readFile(article_path, "utf8"));
  const evaluation = JSON.parse(await readFile(eval_path, "utf8"));
  const requirements = JSON.parse(await readFile(req_path, "utf8"));

  return { article, evaluation, requirements };
};

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
